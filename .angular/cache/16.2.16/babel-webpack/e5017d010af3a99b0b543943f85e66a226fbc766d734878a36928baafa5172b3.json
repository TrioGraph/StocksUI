{"ast":null,"code":"import { throwError, timer } from 'rxjs';\nimport { mergeMap, retryWhen } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nlet RetryInterceptor = /*#__PURE__*/(() => {\n  class RetryInterceptor {\n    intercept(req, next) {\n      // Only retry idempotent methods and only for transient server errors (502,503,504)\n      const shouldRetry = ['GET', 'HEAD', 'OPTIONS'].includes(req.method);\n      if (!shouldRetry) return next.handle(req);\n      const retriableStatus = [502, 503, 504];\n      const maxRetries = 3;\n      const baseDelayMs = 500; // base for exponential backoff\n      return next.handle(req).pipe(retryWhen(error$ => error$.pipe(mergeMap((err, i) => {\n        const attempt = i + 1;\n        const status = err && err.status ? Number(err.status) : null;\n        // not a retriable status -> rethrow immediately\n        if (!status || retriableStatus.indexOf(status) === -1) {\n          return throwError(err);\n        }\n        if (attempt > maxRetries) {\n          return throwError(err);\n        }\n        // respect Retry-After header when available\n        let delayMs = Math.pow(2, attempt - 1) * baseDelayMs;\n        try {\n          const ra = err && err.headers && typeof err.headers.get === 'function' ? err.headers.get('retry-after') : null;\n          if (ra) {\n            const raNum = Number(ra);\n            if (!Number.isNaN(raNum)) {\n              delayMs = raNum * 1000;\n            } else {\n              const then = Date.parse(ra);\n              if (!Number.isNaN(then)) {\n                const diff = then - Date.now();\n                if (diff > 0) delayMs = diff;\n              }\n            }\n          }\n        } catch (e) {\n          // ignore and fall back to backoff\n        }\n        return timer(delayMs);\n      }))));\n    }\n    static {\n      this.ɵfac = function RetryInterceptor_Factory(t) {\n        return new (t || RetryInterceptor)();\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: RetryInterceptor,\n        factory: RetryInterceptor.ɵfac\n      });\n    }\n  }\n  return RetryInterceptor;\n})();\nexport { RetryInterceptor };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}